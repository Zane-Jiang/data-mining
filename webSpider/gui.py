import os

from sklearn.metrics import confusion_matrix
import numpy as np
import itertools
import matplotlib.pyplot as plt
class disp:

    def get_pridict_lable(self,true_path,predict_path):
        '''
        根据输入地址与输出地址，确定混淆矩阵的输入数组
        :param true_path:
        :param predict_path:
        :return:
        '''
        x_true = []
        for cluster_ in os.listdir(true_path):
            for item in os.listdir(true_path+"\\"+cluster_):
                # x_true.append(item.split('.')[0])
                x_true.append(cluster_)
        y_pridict = []
        for cluster_ in os.listdir(predict_path):
            for item in os.listdir(predict_path + "\\" + cluster_):
                # y_pridict.append(item.split('.')[0])
                y_pridict.append(cluster_)
        xy = []
        xy.append(x_true)
        xy.append(y_pridict)
        return xy

    def get_confusion_matrix(self,xy):
        x_true = xy[0]
        y_predict = xy[1]
        return confusion_matrix(x_true,y_predict)







    # def plot_confusion_matrix(self,cm, target_names,title='Confusion matrix',cmap=None,normalize=False):
    #     accuracy = np.trace(cm) / float(np.sum(cm)) #计算准确率
    #     misclass = 1 - accuracy #计算错误率
    #     if cmap is None:
    #         cmap = plt.get_cmap('Blues') #颜色设置成蓝色
    #     plt.figure(figsize=(10, 8)) #设置窗口尺寸
    #     plt.imshow(cm, interpolation='nearest', cmap=cmap) #显示图片
    #     plt.title(title) #显示标题
    #     plt.colorbar() #绘制颜色条
    #     if target_names is not None:
    #         tick_marks = np.arange(len(target_names))
    #         plt.xticks(tick_marks, target_names, rotation=45) #x坐标标签旋转45度
    #         plt.yticks(tick_marks, target_names) #y坐标
    #     if normalize:
    #         cm = cm.astype('float32') / cm.sum(axis=1)
    #         cm = np.round(cm,2) #对数字保留两位小数
    #     thresh = cm.max() / 1.5 if normalize else cm.max() / 2
    #     for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])): #将cm.shape[0]、cm.shape[1]中的元素组成元组，遍历元组中每一个数字
    #         if normalize: #标准化
    #             plt.text(j, i, "{:0.2f}".format(cm[i, j]), #保留两位小数
    #                     horizontalalignment="center",  #数字在方框中间
    #                     color="white" if cm[i, j] > thresh else "black")  #设置字体颜色
    #         else:  #非标准化
    #             plt.text(j, i, "{:,}".format(cm[i, j]),
    #                     horizontalalignment="center",  #数字在方框中间
    #                     color="white" if cm[i, j] > thresh else "black") #设置字体颜色
    #
    #     plt.tight_layout() #自动调整子图参数,使之填充整个图像区域
    #     plt.ylabel('True true') #y方向上的标签
    #     plt.xlabel("Predicted true\naccuracy={:0.4f}\n misclass={:0.4f}".format(accuracy, misclass)) #x方向上的标签
    #     plt.show() #显示图片
    #     labels = ['NORMAL','PNEUMONIA']
    #     # 预测验证集数据整体准确率
    #     Y_pred = model.predict_generator(test_data_gen, total_test // batch_size + 1)
    #     # 将预测的结果转化为one hit向量
    #     Y_pred_classes = np.argmax(Y_pred, axis = 1)
    #     # 计算混淆矩阵
    #     confusion_mtx = confusion_matrix(y_true = test_data_gen.classes,y_pred = Y_pred_classes)
    #     # 绘制混淆矩阵
    #     plot_confusion_matrix(confusion_mtx, normalize=True, target_names=labels)
