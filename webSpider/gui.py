# from sklearn.metrics import confusion_matrix
# import numpy as np
# import itertools
# import matplotlib.pyplot as plt
# class disp:
#     def plot_confusion_matrix(self,cm, target_names,title='Confusion matrix',cmap=None,normalize=False):
#         accuracy = np.trace(cm) / float(np.sum(cm)) #计算准确率
#         misclass = 1 - accuracy #计算错误率
#         if cmap is None:
#             cmap = plt.get_cmap('Blues') #颜色设置成蓝色
#         plt.figure(figsize=(10, 8)) #设置窗口尺寸
#         plt.imshow(cm, interpolation='nearest', cmap=cmap) #显示图片
#         plt.title(title) #显示标题
#         plt.colorbar() #绘制颜色条
#         if target_names is not None:
#             tick_marks = np.arange(len(target_names))
#             plt.xticks(tick_marks, target_names, rotation=45) #x坐标标签旋转45度
#             plt.yticks(tick_marks, target_names) #y坐标
#         if normalize:
#             cm = cm.astype('float32') / cm.sum(axis=1)
#             cm = np.round(cm,2) #对数字保留两位小数
#         thresh = cm.max() / 1.5 if normalize else cm.max() / 2
#         for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])): #将cm.shape[0]、cm.shape[1]中的元素组成元组，遍历元组中每一个数字
#             if normalize: #标准化
#                 plt.text(j, i, "{:0.2f}".format(cm[i, j]), #保留两位小数
#                         horizontalalignment="center",  #数字在方框中间
#                         color="white" if cm[i, j] > thresh else "black")  #设置字体颜色
#             else:  #非标准化
#                 plt.text(j, i, "{:,}".format(cm[i, j]),
#                         horizontalalignment="center",  #数字在方框中间
#                         color="white" if cm[i, j] > thresh else "black") #设置字体颜色
#
#         plt.tight_layout() #自动调整子图参数,使之填充整个图像区域
#         plt.ylabel('True label') #y方向上的标签
#         plt.xlabel("Predicted label\naccuracy={:0.4f}\n misclass={:0.4f}".format(accuracy, misclass)) #x方向上的标签
#         plt.show() #显示图片
#         labels = ['NORMAL','PNEUMONIA']
#         # 预测验证集数据整体准确率
#         Y_pred = model.predict_generator(test_data_gen, total_test // batch_size + 1)
#         # 将预测的结果转化为one hit向量
#         Y_pred_classes = np.argmax(Y_pred, axis = 1)
#         # 计算混淆矩阵
#         confusion_mtx = confusion_matrix(y_true = test_data_gen.classes,y_pred = Y_pred_classes)
#         # 绘制混淆矩阵
#         plot_confusion_matrix(confusion_mtx, normalize=True, target_names=labels)
